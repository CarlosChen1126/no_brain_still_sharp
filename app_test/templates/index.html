<!DOCTYPE html>
<html>
<head>
  <title>Zoom & Pan Webcam Feed</title>
  <style>
    canvas {
      border: 1px solid #333;
      cursor: grab;
    }
    #stream {
      display: none;
    }
  </style>
</head>
<body>
  <h2>Camera Zoom and Pan (with Boundary Lock)</h2>
  <canvas id="canvas" width="640" height="480"></canvas>
  <img id="stream" src="/video_feed" crossorigin="anonymous">

  <script>
    const canvas = document.getElementById('canvas');
    const streamImg = document.getElementById('stream');
    const ctx = canvas.getContext('2d');

    let scale = 1.0;
    let offsetX = 0;
    let offsetY = 0;
    let dragging = false;
    let startX, startY;

    function draw() {
      if (streamImg.complete && streamImg.naturalHeight !== 0) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);
        ctx.drawImage(streamImg, 0, 0);
        ctx.restore();
      }
      requestAnimationFrame(draw);
    }

    streamImg.onload = () => {
      const minScale = Math.max(canvas.width / streamImg.width, canvas.height / streamImg.height);
      if (scale < minScale) scale = minScale;
      draw();
    };

    canvas.addEventListener('wheel', e => {
      e.preventDefault();

      const factor = 1.1;
      const mouseX = (e.offsetX - offsetX) / scale;
      const mouseY = (e.offsetY - offsetY) / scale;

      if (e.deltaY < 0) {
        scale *= factor;
      } else {
        scale /= factor;
      }

      const minScale = Math.max(canvas.width / streamImg.width, canvas.height / streamImg.height);
      if (scale < minScale) scale = minScale;

      offsetX = e.offsetX - mouseX * scale;
      offsetY = e.offsetY - mouseY * scale;

      fixBounds();
    });

    canvas.addEventListener('mousedown', e => {
      dragging = true;
      startX = e.offsetX - offsetX;
      startY = e.offsetY - offsetY;
    });

    canvas.addEventListener('mousemove', e => {
      if (dragging) {
        offsetX = e.offsetX - startX;
        offsetY = e.offsetY - startY;
        fixBounds();
      }
    });

    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);

    function fixBounds() {
      const scaledWidth = streamImg.width * scale;
      const scaledHeight = streamImg.height * scale;

      if (scaledWidth <= canvas.width) {
        offsetX = (canvas.width - scaledWidth) / 2;
      } else {
        offsetX = Math.min(0, Math.max(offsetX, canvas.width - scaledWidth));
      }

      if (scaledHeight <= canvas.height) {
        offsetY = (canvas.height - scaledHeight) / 2;
      } else {
        offsetY = Math.min(0, Math.max(offsetY, canvas.height - scaledHeight));
      }
    }
  </script>
</body>
</html>
